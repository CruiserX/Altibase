/** 
 *  Copyright (c) 1999~2017, Altibase Corp. and/or its affiliates. All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License, version 3,
 *  as published by the Free Software Foundation.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
 
/*******************************************************************************
 * $Id: acvLicenseMaker.c 11010 2010-05-06 02:40:10Z gurugio $
 ******************************************************************************/

#include <acp.h>
#include <acl.h>
#include <acv.h>

#define ACV_MAKER_COPYRIGHT \
    "-----------------------------------------------------------------\n"\
    "  Altibase License Maker Utility\n"\
    "  Release Version 1.0.0.0\n"\
    "  Built on " __DATE__ " / " __TIME__ "\n"\
    "  Copyright 2009, ALTIBASE Corporation or its subsidiaries.\n"\
    "  All Rights Reserved.\n"\
    "-----------------------------------------------------------------\n"

/* Tokens to write to license file */
acp_char_t* gTokens[10] =
{
    "Licensing Provider : ", "Licensing Product : ", "Type of License : ",
    "License Key : ", "Expiration Date : ", "Expiration Network Traffic : ",
    "ID : ", "Checksum1 : ", "Checksum2 : ", "Information : "
};

/* Kind of OSes -> defined at acv.h */
acp_char_t* gKindOS[] =
{
    ACV_OS_LINUX, ACV_OS_SOLARIS, ACV_OS_HPUX,
    ACV_OS_AIX, ACV_OS_TRU64, ACV_OS_WINDOWS, NULL
};

/* Kind of Product */
acp_char_t* gKindProduct[] = {"Altibase DBMS", "Altibase ADI", "Altibase ADS"};
/* Short Product Names */
acp_char_t* gKindProductShort[] = { "DBMS", "ADI", "ADS" };

/* Default license file path */
#define ACV_LINE_LENGTH     128

typedef enum acvOptions
{
    ACV_OPTION_OPERATING_SYSTEM = 1,
    ACV_OPTION_SYSTEM_ID        = 2,
    ACV_OPTION_PRODUCT          = 3,
    ACV_OPTION_EXPIRE           = 4,
    ACV_OPTION_REQUEST          = 5,
    ACV_OPTION_LICENSE          = 6,
    ACV_OPTION_HELP             = 7,
    ACV_OPTION_SILENT           = 8
} acvOptions;

/* Options */
static acp_opt_def_t gOptDef[] = 
{
    {
        ACV_OPTION_HELP,
        ACP_OPT_ARG_NOTEXIST,
        'h', "help", NULL, "Help",
        "Print This Help Screen"
    },
    {
        ACV_OPTION_OPERATING_SYSTEM,
        ACP_OPT_ARG_REQUIRED,
        'o', "os", NULL, "Operating Systems",
        "Target Operating System."
    },
    {
        ACV_OPTION_SYSTEM_ID,
        ACP_OPT_ARG_REQUIRED,
        'i', "id", NULL, "System ID",
        "Target Machine's ID"
    },
    {
        ACV_OPTION_PRODUCT,
        ACP_OPT_ARG_REQUIRED,
        'p', "product", NULL, "Product",
        "Target Product to License (DBMS/ADI/ADS)"
    },
    {
        ACV_OPTION_EXPIRE,
        ACP_OPT_ARG_REQUIRED,
        'e', "expire", NULL, "Expiration Date",
        "In form of YYYYMMDD or Permanent"
    },
    {
        ACV_OPTION_REQUEST,
        ACP_OPT_ARG_REQUIRED,
        'r', "request", NULL, "Path",
        "Request File Generated by Installer"
    },
    {
        ACV_OPTION_LICENSE,
        ACP_OPT_ARG_REQUIRED,
        'l', "auth", NULL, "Path",
        "Authorization File to Generate"
    },
    {
        ACV_OPTION_SILENT,
        ACP_OPT_ARG_NOTEXIST,
        's', "silent", NULL, "Silent",
        "Prints nothing but key and information"
    },
    ACP_OPT_SENTINEL
};

/* Exception Handler */
static void acvExceptionHandler(acp_sint32_t aSignal,
                                acp_callstack_t* aCallstack)
{
    ACP_UNUSED(aCallstack);
    (void)acpPrintf("Caught a signal %d\n", aSignal);
    acpProcExit(0);
}

/* Drop : and - at Mac Address string */
void acvDropEtc(acp_char_t* aLine)
{
    acp_char_t* sNext = aLine;

    do /* Drop : and -. make all uppercase */
    {
        if(':' == *aLine || '-' == *aLine)
        {
            aLine++;
        }
        else
        {
            *sNext = acpCharToUpper(*aLine);
            if('\0' == *sNext)
            {
                sNext[0] = sNext[1] = sNext[2] = sNext[3] = '0';
                sNext[4] = '\0';
                break;
            }
            else
            {
                sNext++;
                aLine++;
            }
        }
    } while(ACP_TRUE);
}

/* Check whether mac address is proper 
 * With Windows and Linux */
acp_bool_t acvCheckMacAddress(acv_license_request_t* aReq)
{
    acp_sint32_t i;
    acp_sint32_t sLen;

    aReq->mIDisRaw = ACP_FALSE;

    sLen = (acp_sint32_t)acpCStrLen(aReq->mID, ACV_LINE_LENGTH);
    for(i = 0; i < sLen; i++)
    {
        if(':' == aReq->mID[i] || '-' == aReq->mID[i])
        {
            aReq->mIDisRaw = ACP_TRUE;
            acvDropEtc(aReq->mID);
            break;
        }
        else
        {
            /* Loop! */
        }
    }

    return
        ((ACP_TRUE == aReq->mIDisRaw && 17 == sLen) ||
         (ACP_FALSE == aReq->mIDisRaw && 16 == sLen)) ? ACP_TRUE : ACP_FALSE;
}

/* Check whether machine identity is proper
 * With HP-UX */
acp_bool_t acvCheckMachineIdent(acv_license_request_t* aReq)
{
    acp_sint32_t sLen;
    sLen = (acp_sint32_t)acpCStrLen(aReq->mID, ACV_LINE_LENGTH);
    return (9 == sLen || 36 == sLen)? ACP_TRUE : ACP_FALSE;
}

/* Check whether Host id is proper
 * with Solaris, AIX, TRU64 */
acp_bool_t acvCheckHostID(acv_license_request_t* aReq)
{
    if(0 == acpCStrCmp(aReq->mID, "0X", 2))
    {
        (void)acpCStrCpy(aReq->mID, ACV_LINE_LENGTH,
                         aReq->mID + 2, ACV_LINE_LENGTH);
    }
    else
    {
        /* Do nothing */
    } 

    return (8 == acpCStrLen(aReq->mID, ACV_LINE_LENGTH)) ?
        ACP_TRUE : ACP_FALSE;
}

/* Check OS and ID */
acp_bool_t acvCheckOSandID(acv_license_request_t* aReq)
{
    typedef acp_bool_t acvCheckIDType(acv_license_request_t*);
    acp_bool_t sTR = ACP_FALSE;

    /* Functions to check consistency */
    acvCheckIDType* sCheckFunc[] = 
    {
        acvCheckMacAddress, acvCheckHostID, acvCheckMachineIdent,
        acvCheckHostID, acvCheckHostID, acvCheckMacAddress, NULL
    };

    /* User did not enter Operating System.
     * Get one from stdin */
    if(0 == acpCStrLen(aReq->mOSType, ACV_LINE_LENGTH))
    {
        sTR = ACP_TRUE;
    }
    else
    {
        acp_sint32_t i;
        
        for(i = 0; NULL != gKindOS[i]; i++)
        {
            if((0 == acpCStrCmp(aReq->mOSType, gKindOS[i], ACV_LINE_LENGTH)))
            {
                /* Check whether OS type and ID is consistent */
                sTR = (*sCheckFunc[i])(aReq);
                break;
            }
            else
            {
                /* Loop */
            }
        }

        if(NULL == gKindOS[i])
        {
            /* Operating System Not Supported */
            (void)acpPrintf("Unsupported OS Type! : %s\n", aReq->mOSType);
            sTR = ACP_FALSE;
        }
        else
        {
            /* Do nothing */
        }
    }

    return sTR;
}

/* Get license file path */
void acvGetLicenseFile(acv_license_request_t* aReq)
{
    acp_rc_t sRC;
    acp_char_t sLine[ACV_LINE_LENGTH];

    if((0 == acpCStrLen(aReq->mLicense, 8)) && (ACP_FALSE == aReq->mIsSilent))
    {
        (void)acpPrintf("Enter License file to write : ");
        sRC = acpStdGetCString(ACP_STD_IN, sLine, ACV_LINE_LENGTH);
        if(ACP_RC_IS_SUCCESS(sRC))
        {
            acvDropEnter(sLine, ACV_LINE_LENGTH);
            if(0 == acpCStrLen(sLine, 8))
            {
                /* Do nothing */
            }
            else
            {
                (void)acpCStrCpy(aReq->mLicense, ACV_LINE_LENGTH,
                                 sLine, ACV_LINE_LENGTH);
            }
        }
        else
        {
            (void)acpPrintf("Error while reading!\n");
            acpProcExit(0);
        }
    }
    else
    {
        /* Do nothing */
    }
}

/* Add date */
void acvAddDate(acp_time_t aTime, acp_sint32_t aYear, acp_sint32_t aMonth,
                acp_sint32_t aDay, acp_time_exp_t* aTimeExp)
{
    acp_sint32_t sDaysOfMonth[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    acpTimeGetLocalTime(aTime, aTimeExp);

    aTimeExp->mYear += aYear;
    aTimeExp->mMonth += aMonth;
    aTimeExp->mDay += aDay;

    /* Adjust if month is greater than 12 */
    if(aTimeExp->mMonth > 12)
    {
        aTimeExp->mYear++;
        aTimeExp->mMonth -= 12;
    }
    else
    {
        /* Do nothing */
    }

    /* Adjust if day is greater than month of date */
    do
    {
        if((0 == aTimeExp->mYear % 400) ||
           ((0 != aTimeExp->mYear % 100) && (0 == aTimeExp->mYear % 4)))
        {
            sDaysOfMonth[2] = 29;
        }
        else
        {
            /* sDaysOfMonth[2] = 28; */
        }
        
        if(aTimeExp->mDay > sDaysOfMonth[aTimeExp->mMonth])
        {
            aTimeExp->mDay -= sDaysOfMonth[aTimeExp->mMonth];
            aTimeExp->mMonth++;
        }
        else
        {
            break;
        }

        /* Adjust if month is greater than 12 */
        if(aTimeExp->mMonth > 12)
        {
            aTimeExp->mYear++;
            aTimeExp->mMonth -= 12;
        }
        else
        {
            /* Do nothing */
        }
    } while(ACP_TRUE);
}

/* Get product name */
void acvGetProduct(acv_license_request_t* aReq)
{
    acp_bool_t sLoop;
    acp_sint32_t i;
    acp_char_t sLine[ACV_LINE_LENGTH];
    acp_rc_t sRC;

    if(0 == acpCStrLen(aReq->mProduct, ACV_LINE_LENGTH))
    {
        sLoop = ACP_TRUE;

        do /* Loop for read proper Licensing Product */
        {
            (void)acpPrintf("Select Licensing Product\n");
            for(i = 0; i < 3; i++)
            {
                (void)acpPrintf("\t %d. %s\n", i+1, gKindProduct[i]);
            }
            (void)acpPrintf("Enter 1-3 : ");
            
            sRC = acpStdGetCString(ACP_STD_IN, sLine, ACV_LINE_LENGTH);
            if(ACP_RC_IS_SUCCESS(sRC))
            {
                acp_sint32_t sPrSel;
                acp_sint32_t sSign;
                acp_uint32_t sSel;
                
                acvDropEnter(sLine, ACV_LINE_LENGTH);
                
                sRC = acpCStrToInt32(sLine, 3, &sSign, &sSel, 10, NULL);
                if(ACP_RC_IS_SUCCESS(sRC))
                {
                    sPrSel = sSel * sSign;

                    if((sSel >= 1) && (sSel <= 3))
                    {
                        (void)acpCStrCpy(
                            aReq->mProduct, ACV_LINE_LENGTH,
                            gKindProduct[sPrSel - 1], ACV_LINE_LENGTH);
                        sLoop = ACP_FALSE;
                    }
                    else
                    {
                        (void)acpPrintf("Invalid Input!\n");
                    }
                }
                else
                {
                    (void)acpPrintf("Invalid Input!\n");
                }

            }
            else
            {
                (void)acpPrintf("Error while reading!\n");
                continue;
            }
        } while(ACP_TRUE == sLoop);
    }
    else
    {
        acp_bool_t sFound = ACP_FALSE;
        (void)acpCStrToUpper(aReq->mProduct, ACV_LINE_LENGTH);

        /* Make short product name to long
         * DBMS -> Altibase DBMS
         * ADI  -> Altibase ADI
         * ADS -> Altibase ADS */
        for(i = 0; i < 3; i++)
        {
            if(0 == acpCStrCmp(gKindProductShort[i],
                               aReq->mProduct, ACV_LINE_LENGTH))
            {
                (void)acpCStrCpy(aReq->mProduct, ACV_LINE_LENGTH,
                                 gKindProduct[i], ACV_LINE_LENGTH);
                sFound = ACP_TRUE;
                break;
            }
            else
            {
                /* Loop */
            }
        }

        if(ACP_FALSE == sFound)
        {
            (void)acpPrintf("You Entered Invalid Product name!\n");
            acpProcExit(0);
        }
        else
        {
            /* Do nothing
             * Got a proper product */
        }
    }
}

/* Check date consistency */
void acvCheckExpiryDate(acp_char_t* aDate)
{
    if(ACV_DATE_LENGTH == acpCStrLen(aDate, ACV_LINE_LENGTH))
    {
        acp_sint32_t i;

        for(i = 0; i < ACV_DATE_LENGTH; i++)
        {
            if(aDate[i] >= '0' && aDate[i] <= '9')
            {
                /* In format, continue loop */
            }
            else
            {
                (void)acpPrintf("You must specify YYYYMMDD format\n");
                acpProcExit(0);
            }
        }
    }
    else
    {
        (void)acpPrintf("You must specify YYYYMMDD format\n");
        acpProcExit(0);
    }
}

/* Get Expiry Date */
void acvGetExpiryDate(acv_license_request_t* aReq)
{
    acp_bool_t sLoop;
    acp_char_t sLine[ACV_LINE_LENGTH];
    acp_sint32_t i;
    acp_rc_t sRC;

    if(0 == acpCStrLen(aReq->mExpire, ACV_LINE_LENGTH))
    {
        sLoop = ACP_TRUE;
        do /* Loop for read proper Expiration Date */
        {
            acp_time_t sNow = acpTimeNow();
            acp_time_exp_t sDates[7];
            acp_char_t* sPeriod[7] = 
            {
                "Permanent   ", "One Week    ", "Two Weeks   ", "One Month   ",
                "Two Months  ", "Three Months", "A Year      "
            };

            acvAddDate(sNow, 0, 0,  7, &sDates[1]);
            acvAddDate(sNow, 0, 0, 14, &sDates[2]);
            acvAddDate(sNow, 0, 1,  0, &sDates[3]);
            acvAddDate(sNow, 0, 2,  0, &sDates[4]);
            acvAddDate(sNow, 0, 3,  0, &sDates[5]);
            acvAddDate(sNow, 1, 0,  0, &sDates[6]);
            
            (void)acpPrintf("Select Expiry Date\n");
            (void)acpPrintf("\t 1. Permanent\n");
            for(i = 1; i < 7; i++)
            {
                (void)acpPrintf(
                    "\t %d. %s     ~(%04d/%02d/%02d)\n",
                    i + 1, sPeriod[i],
                    sDates[i].mYear,
                    sDates[i].mMonth,
                    sDates[i].mDay);
            }
                
            (void)acpPrintf("Enter 1-7 [1] : ");
            sRC = acpStdGetCString(ACP_STD_IN, sLine, ACV_LINE_LENGTH);
            if(ACP_RC_IS_SUCCESS(sRC))
            {
                acp_sint32_t sSign;
                acp_uint32_t sSel;


                acvDropEnter(sLine, ACV_LINE_LENGTH);
                if(0 == acpCStrLen(sLine, 3))
                {
                    sRC = ACP_RC_SUCCESS;
                    sSign = 1;
                    sSel = 1;
                }
                else
                {
                    sRC = acpCStrToInt32(sLine, 3, &sSign, &sSel, 10, NULL);
                }

                if(ACP_RC_IS_SUCCESS(sRC))
                {
                    switch(sSign * sSel)
                    {
                    case 1:
                        acpMemSet(aReq->mExpire, 0, 8);
                        sLoop = ACP_FALSE;
                        break;
                    case 2: case 3: case 4: case 5: case 6: case 7:
                        (void)acpSnprintf(
                            aReq->mExpire, 9, "%04d%02d%02d",
                            sDates[sSel - 1].mYear,
                            sDates[sSel - 1].mMonth,
                            sDates[sSel - 1].mDay);
                        sLoop = ACP_FALSE;
                        break;
                    default:
                        (void)acpPrintf("Invalid Input! ");
                        break;
                    }
                }
                else
                {
                    (void)acpPrintf("Invalid Input! ");
                }
            }
            else
            {
                (void)acpPrintf("Error while reading!\n");
                acpProcExit(0);
            }
        } while(ACP_TRUE == sLoop);
    }
    else
    {
        (void)acpCStrToUpper(aReq->mExpire, ACV_LINE_LENGTH);

        if(0 == acpCStrCmp(aReq->mExpire, "PERMANENT", ACV_LINE_LENGTH))
        {
            acpMemSet(aReq->mExpire, 0, ACV_LINE_LENGTH);
        }
        else
        {
            acvCheckExpiryDate(aReq->mExpire);
        }
    }

}

/* Enter OS */
acp_bool_t acvEnterOS(acv_license_request_t* aReq, acp_sint32_t* aOSSel)
{
    acp_char_t sLine[ACV_LINE_LENGTH];
    acp_bool_t sTR = ACP_FALSE;
    acp_sint32_t i;
    acp_rc_t sRC;

    (void)acpPrintf("Select Target Operating System\n");
    for(i = 0; i < 6; i++)
    {
        (void)acpPrintf("\t %d. %s\n", i + 1, gKindOS[i]);
    }

    (void)acpPrintf("Enter 1-6 : ");
    sRC = acpStdGetCString(ACP_STD_IN, sLine, ACV_LINE_LENGTH);
    if(ACP_RC_IS_SUCCESS(sRC))
    {
        acp_sint32_t sSign;
        acp_uint32_t sSel;

        acvDropEnter(sLine, ACV_LINE_LENGTH);
        sRC = acpCStrToInt32(sLine, 3, &sSign, &sSel, 10, NULL);
        
        if(ACP_RC_IS_SUCCESS(sRC))
        {
            *aOSSel = (acp_uint32_t)(sSel * sSign);

            if( (*aOSSel >= 1) && (*aOSSel <= 6))
            {
                (*aOSSel)--;
                (void)acpCStrCpy(aReq->mOSType, ACV_LINE_LENGTH,
                                 gKindOS[*aOSSel], ACV_LINE_LENGTH);
                sTR = ACP_TRUE;
            }
            else
            {
                (void)acpPrintf("Invalid Input! ");
                sTR = ACP_FALSE;
            }
            
        }
        else
        {
            (void)acpPrintf("Invalid Input! ");
            sTR = ACP_FALSE;
        }
    }
    else
    {
        (void)acpPrintf("Error while reading!\n");
        acpProcExit(0);
    }

    return sTR;
}

/* Get Operting System */
void acvGetOS(acv_license_request_t* aReq)
{
    /* ID Type according to OS Type */
    static acp_char_t* sIDType[6] = 
    {
        "Mac Address\n\t($ ifconfig eth0 - HWaddr [XX:XX:XX:XX:XX:XX])",
        "Host ID\n\t($ hostid - XXXXXXXX or 0x00000000 : 8 hexadecimal)",
        "Machine Identity($ getconf MACHINE_IDENT)\n"
            "\tXXXXXXXXX for HP-UX 11i v1\n"
            "\tXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX for HP-UX 11i v2, v3 \n",
        "Host ID\n\t($ hostid - XXXXXXXX or 0x00000000 : 8 hexadecimal)",
        "Host ID\n\t($ hostid - XXXXXXXX or 0x00000000 : 8 hexadecimal)",
        "Mac Address\n"
            "\t(C:\\> ipconfig /all - Physical Address [XX-XX-XX-XX-XX-XX])"
    };

    acp_char_t   sLine[ACV_LINE_LENGTH];
    acp_sint32_t sOSSel = 0;
    acp_bool_t   sLoop;
    acp_rc_t     sRC;

    if(0 == acpCStrLen(aReq->mOSType, ACV_LINE_LENGTH))
    {
        while(ACP_FALSE == acvEnterOS(aReq, &sOSSel))
        {
            /* Loop to read proper os */
        }
        
        sLoop = ACP_TRUE;
        do /* Loop for read proper Licensing Product */
        {
            (void)acpPrintf("For %s, Machine ID is %s\n",
                            aReq->mOSType, sIDType[sOSSel]);
            (void)acpPrintf("Enter machine ID : ");

            sRC = acpStdGetCString(ACP_STD_IN, sLine, ACV_LINE_LENGTH);
            if(ACP_RC_IS_SUCCESS(sRC))
            {
                acvDropEnter(sLine, ACV_LINE_LENGTH);
                (void)acpCStrCpy(aReq->mID, ACV_LINE_LENGTH,
                                 sLine, ACV_LINE_LENGTH);

                if(ACP_FALSE == acvCheckOSandID(aReq))
                {
                    (void)acpPrintf("You must enter valid ID!\n");
                    continue;
                }
                else
                {
                    /* End loop */
                    sLoop = ACP_FALSE;
                }
            }
            else
            {
                (void)acpPrintf("Error while reading!\n");
                acpProcExit(0);
            }
        } while(ACP_TRUE == sLoop);
    }
    else
    {
        (void)acpCStrToUpper(aReq->mOSType, ACV_LINE_LENGTH);
        if(ACP_FALSE == acvCheckOSandID(aReq))
        {
            (void)acpPrintf("OS Type and System ID is inconsistent!\n");
            acpProcExit(0);
        }
        else
        {
            /* End loop */
            sLoop = ACP_FALSE;
        }
    }
}

void acvGenerateLicenseFile( acv_license_request_t* aReq,
                             acp_uint8_t* aLicenseKey,
                             acp_uint8_t* aEncLic)
{
    acp_std_file_t sFile;
    acp_sint32_t    i;

    if(acpCStrLen(aReq->mLicense, 8) > 0)
    {
        /* Write license file */
        acp_rc_t sRC = acpStdOpen(&sFile, aReq->mLicense,
                                  ACP_STD_OPEN_WRITE_TRUNC);
        if(ACP_RC_IS_SUCCESS(sRC))
        {
            (void)acpFprintf(&sFile, "%s%s\n", gTokens[1], aReq->mProduct);
            (void)acpFprintf(&sFile, "%s", gTokens[3]);
            for(i = 0; i < ACL_LIC_KEYLENGTH; i++)
            {
                (void)acpFprintf(&sFile, "%02X", aLicenseKey[i]);
            }
            (void)acpFprintf(&sFile, "\n");

            (void)acpFprintf(&sFile, "%s", gTokens[9]);
            for(i = 0; i < ACL_LIC_DATALENGTH; i++)
            {
                (void)acpFprintf(&sFile, "%02X", aEncLic[i]);
            }
            (void)acpFprintf(&sFile, "\n");

            (void)acpStdClose(&sFile);
        }
        else
        {
            (void)acpPrintf("Error opening %s\n", aReq->mLicense);
        }
    }
    else
    {
        /* Do nothing */
    }
}

/* Make License file */
void acvEvaluate( acv_license_request_t* aReq )
{
    acp_char_t sProvider[ACV_LINE_LENGTH] = "Altibase Co. Ltd.";
    acp_char_t sType[ACV_LINE_LENGTH] = "Normal";

    acp_uint8_t sLicenseKey[ACL_LIC_KEYLENGTH];
    acp_uint8_t sEncKey[ACL_LIC_KEYLENGTH];
    acp_uint8_t sID[ACV_LINE_LENGTH];
    acp_uint8_t sEncID[ACV_LINE_LENGTH];
    acp_uint32_t i;
    acp_uint32_t sSeed = 0;

    acl_lic_data_t sLic;
    acp_uint8_t    sEncLic[ACL_LIC_DATALENGTH];

    if(ACP_FALSE == aReq->mIsSilent)
    {
        (void)acpPrintf(ACV_MAKER_COPYRIGHT);
    }
    else
    {
        /* Silent Mode */
    }

    acvGetOS(aReq);

    if(ACP_FALSE == aReq->mIsSilent)
    {
        (void)acpPrintf("Generating License for\n\tOS Type [%s]\n"
                        "\tID      [%s]\n",
                        aReq->mOSType, aReq->mID);
        (void)acpPrintf("License Provider is Altibase Co. Ltd.\n");
    }
    else
    {
        /* Print Nothing */
    }

    /* If left blank, get proper values */
    acvGetProduct(aReq);
    acvGetExpiryDate(aReq);
    acvGetLicenseFile(aReq);

    /* License Key is just a 16bytes random value */
    sSeed = acpRandSeedAuto();
    for(i = 0; i < ACL_LIC_KEYLENGTH; i++)
    {
        sLicenseKey[i] = acpRand(&sSeed) % 256;
    }
    (void)aclCryptTEAEncipher(sLicenseKey, sLicenseKey, sEncKey, 
                              ACL_LIC_KEYLENGTH, ACL_LIC_KEYLENGTH);

    (void)acpMemSet(sID, 0, ACV_LINE_LENGTH);
    (void)acpMemCpy(sID, aReq->mID, acpCStrLen(aReq->mID, ACV_LINE_LENGTH));
    (void)aclCryptTEAEncipher(sID, sLicenseKey, sEncID,
                              ACV_LINE_LENGTH, ACL_LIC_KEYLENGTH);
    (void)acpMemSet(&sLic, 0, ACL_LIC_DATALENGTH);

    /* Copy data */
    sLic.mVersionMajor = 1;
    sLic.mVersionMinor = 0;
    sLic.mVersionPatch = 0;
    sLic.mVersionMisc  = 1;

    (void)acpMemCpy(sLic.mKey, sLicenseKey, ACL_LIC_KEYLENGTH);
    (void)acpMemCpy(sLic.mProducts, aReq->mProduct, ACV_LINE_LENGTH);
    (void)acpMemCpy(sLic.mExpireDate, aReq->mExpire, 8); 
    (void)acpMemSet(sLic.mExpireTraffic, 0, 16);

    /* Copy ID Type and ID */
    (void)acpMemCpy(sLic.mID, sID,
                    acpCStrLen((acp_char_t*)sID, ACV_LINE_LENGTH));

    /* Encrypt License Info */
    (void)aclCryptTEAEncipher(&sLic, sLicenseKey, sEncLic, ACL_LIC_DATALENGTH,
                              ACL_LIC_KEYLENGTH);

    if(ACP_FALSE == aReq->mIsSilent)
    {
        /* Write to stdout */
        (void)acpPrintf("==================================\n");

        (void)acpPrintf("Version : %d.%d.%d.%d\n",
                        sLic.mVersionMajor, sLic.mVersionMinor,
                        sLic.mVersionPatch, sLic.mVersionMisc);

        (void)acpPrintf("%s%s\n", gTokens[0], sProvider);
        (void)acpPrintf("%s%s\n", gTokens[1], aReq->mProduct);
        (void)acpPrintf("%s%s\n", gTokens[2], sType);
        (void)acpPrintf("%s", gTokens[3]);
    }
    else
    {
        /* Silent Mode Again */
    }

    for(i = 0; i < ACL_LIC_KEYLENGTH; i++)
    {
        (void)acpPrintf("%02X", sLicenseKey[i]);
    }
    (void)acpPrintf("\n");

    if(ACP_FALSE == aReq->mIsSilent)
    {
        (void)acpPrintf("%s%s\n", gTokens[4], aReq->mExpire);
        (void)acpPrintf("%s%s\n", gTokens[6], aReq->mID);
        (void)acpPrintf("%s", gTokens[7]);

        for(i = 0; i < ACL_LIC_KEYLENGTH; i++)
        {
            (void)acpPrintf("%02X", sEncID[i]);
        }
        (void)acpPrintf("\n");

        (void)acpPrintf("%s", gTokens[8]);
        for(i = 0; i < ACL_LIC_KEYLENGTH; i++)
        {
            (void)acpPrintf("%02X", sEncKey[i]);
        }
        (void)acpPrintf("\n");
        (void)acpPrintf("%s", gTokens[9]);
    }
    else
    {
        /* Silent Mode Again and Again */
    }

    for(i = 0; i < ACL_LIC_DATALENGTH; i++)
    {
        (void)acpPrintf("%02X", sEncLic[i]);
    }
    (void)acpPrintf("\n");

    if(ACP_FALSE == aReq->mIsSilent)
    {
        (void)acpPrintf("================================== Done.\n");
    }
    else
    {
        /* Still Silent Mode */
    }

    acvGenerateLicenseFile(aReq, sLicenseKey, sEncLic);
}

/* Parse Request file */
acp_bool_t acvParseRequest(acv_license_request_t* aReq)
{
    acp_bool_t sTR = ACP_TRUE;
    acp_bool_t sOSRead = ACP_FALSE;
    acp_bool_t sIDRead = ACP_FALSE;

    if(NULL == aReq)
    {
        (void)acpPrintf("Internal Error!\n");
        acpProcExit(0);
    }
    else
    {
        acp_rc_t sRC;
        acp_char_t sLine[ACV_LINE_LENGTH];
        acp_bool_t sEOF;
        acp_std_file_t sFile;

        sRC = acpStdOpen(&sFile, aReq->mRequest, ACP_STD_OPEN_READ);
        if(ACP_RC_NOT_SUCCESS(sRC))
        {
            (void)acpPrintf("Cannot Open %s\n", aReq->mRequest);
            acpProcExit(0);
        }
        else
        {
            /* Fall through */
        }
        
        while(ACP_RC_IS_SUCCESS(sRC))
        {
            sRC = acpStdGetCString(&sFile, sLine, ACV_LINE_LENGTH);
            
            if(ACP_RC_IS_SUCCESS(sRC))
            {
                sRC = acpStdIsEOF(&sFile, &sEOF);
                if(ACP_RC_NOT_SUCCESS(sRC))
                {
                    (void)acpPrintf("Error while reading %s\n", aReq->mRequest);
                    acpProcExit(0);
                }
                else if(ACP_TRUE == sEOF)
                {
                    break;
                }
                else
                {
                    /* Fall through */
                }
                
                acvDropEnter(sLine, ACV_LINE_LENGTH);
                if(5 > acpCStrLen(sLine, ACV_LINE_LENGTH))
                {
                    /* Empty Line */
                    continue;
                }
                else
                {
                    /* Fall through */
                }
                
                if(0 == acpCStrCmp(sLine, "OS : ", 5))
                {
                    /* Line indicates OS */
                    (void)acpCStrCpy(aReq->mOSType, ACV_LINE_LENGTH,
                                     sLine + 5, ACV_LINE_LENGTH);
                    sOSRead = ACP_TRUE;
                }
                else if(0 == acpCStrCmp(sLine, "ID : ", 5))
                {
                    (void)acpCStrCpy(aReq->mID, ACV_LINE_LENGTH,
                                     sLine + 5, ACV_LINE_LENGTH);
                    sIDRead = ACP_TRUE;
                }
                else
                {
                    /* Ignore Line */
                }
            }
            else
            {
                (void)acpPrintf("Error while reading request %s\n",
                                aReq->mRequest);
                acpProcExit(0);
            }
        }
        
        /* A.C.V. good to go sir! */
        (void)acpStdClose(&sFile);
    }

    sTR = ((ACP_TRUE == sOSRead) && (ACP_TRUE == sIDRead))?
        ACP_TRUE : ACP_FALSE;

    return sTR;
}

/* Check options have been correctly entered */
acp_bool_t acvCheckCommandLineConsistency(acv_license_request_t* aReq)
{
    acp_bool_t sTR = ACP_TRUE;

    /* OS and ID must be entered together */
    if(((0 == acpCStrLen(aReq->mOSType, 3)) &&
        (0 != acpCStrLen(aReq->mID, 3)))
       ||
       ((0 != acpCStrLen(aReq->mOSType, 3)) &&
        (0 == acpCStrLen(aReq->mID, 3)))
       )
    {
        (void)acpPrintf("You must enter both OS Type and ID\n");
        sTR = ACP_FALSE;
    }
    /* OS/ID and request path cannot be entered together */
    else if(0 != acpCStrLen(aReq->mRequest, 3))
    {
        if(0 != acpCStrLen(aReq->mOSType, 3))
        {
            (void)acpPrintf("You cannot enter both "
                            "OS Type/ID and Request Path\n");
            sTR = ACP_FALSE;
        }
        else
        {
            sTR = acvParseRequest(aReq);
        }
    }
    /* Valid options */
    else
    {
        sTR = ACP_TRUE;
    }

    return sTR;
}

/* Print Usage */
void acvPrintUsage(void)
{
    acp_char_t sHelp[ACV_LINE_LENGTH * 32] = { 0, };
    
    (void)acpPrintf(ACV_MAKER_COPYRIGHT);
    (void)acpOptHelp(gOptDef, NULL, sHelp, sizeof(sHelp) - 1);
    (void)acpPrintf("%s\n", sHelp);
    acpProcExit(0);
}

acp_sint32_t main(acp_sint32_t aArgc, acp_char_t** aArgv)
{
    acp_opt_t    sOpt;
    acp_sint32_t sValue;
    acp_rc_t     sRC;
    acp_char_t  *sArg = NULL;
    acp_char_t   sError[ACV_LINE_LENGTH * 2] = {0, };
    acv_license_request_t sReq = ACV_LICENSE_REQUEST_INIT;

    (void)acpSignalSetExceptionHandler(acvExceptionHandler);

    if(1 == aArgc)
    {
        acvEvaluate(&sReq);
        acpProcExit(0);
    }
    else
    {
        /* Fall through */
    }

    sRC = acpOptInit(&sOpt, aArgc, aArgv);

    if(ACP_RC_NOT_SUCCESS(sRC))
    {
        (void)acpPrintf("Internal Error!\n");
    }
    else
    {
        acp_char_t* sDestination[] = 
        {
            sReq.mOSType, sReq.mID, sReq.mProduct,
            sReq.mExpire, sReq.mRequest, sReq.mLicense
        };

        /* Parse Command Line */
        while(1)
        {
            sRC = acpOptGet(&sOpt, gOptDef, NULL, &sValue, &sArg,
                            sError, sizeof(sError) - 1);

            if(ACP_RC_IS_SUCCESS(sRC))
            {
                switch(sValue)
                {
                    case ACV_OPTION_HELP:
                        acvPrintUsage();
                        break;
                    case ACV_OPTION_SILENT:
                        sReq.mIsSilent = ACP_TRUE;
                        break;
                    default:
                        (void)acpCStrCpy(sDestination[sValue - 1],
                                         ACV_LINE_LENGTH,
                                         sArg, ACV_LINE_LENGTH);
                        break;
                }
            }
            else
            {
                /* Generate License */
                if(ACP_TRUE == acvCheckCommandLineConsistency(&sReq))
                {
                    acvEvaluate(&sReq);
                }
                else
                {
                    acvPrintUsage();
                }
                break;
            }
        }
    }

    return 0;
}
